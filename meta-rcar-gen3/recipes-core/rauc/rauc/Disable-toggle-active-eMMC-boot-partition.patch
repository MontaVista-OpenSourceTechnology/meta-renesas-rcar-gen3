Index: rauc-1.1/src/update_handler.c
===================================================================
--- rauc-1.1.orig/src/update_handler.c
+++ rauc-1.1/src/update_handler.c
@@ -1241,40 +1241,6 @@ static gboolean img_to_boot_emmc_handler
 		goto out;
 	}
 
-	/* toggle active boot partition in ext_csd register; do this explicitly on
-	 * determined boot partition to force the kernel to switch to the partition;
-	 * for simplicity reasons: in case the user partition is active use
-	 * mmcblkXboot1, in case no partition is active use mmcblkXboot0
-	 */
-	g_debug("Toggling active eMMC boot partition %s -> %s", part_active_str,
-			part_slot->device);
-	res = r_emmc_write_bootpart(
-			part_slot->device,
-			INACTIVE_BOOT_PARTITION(part_active),
-			&ierror);
-	if (!res) {
-		g_propagate_error(error, ierror);
-		goto out;
-	}
-
-	/* sanity check: read active boot partition from ext_csd
-	 *
-	 * Read explicitly from root device (this forces another kernel
-	 * partition switch and should trigger the ext_csd bug more reliably).
-	 */
-	res = r_emmc_read_bootpart(dest_slot->device, &part_active_after, &ierror);
-	if (!res) {
-		g_propagate_error(error, ierror);
-		goto out;
-	}
-
-	if (part_active == part_active_after) {
-		g_set_error(error, R_UPDATE_ERROR, R_UPDATE_ERROR_FAILED,
-				"Toggling the boot partition failed! Your kernel is most-likely affected by the ioctl ext_csd bug: see http://rauc.readthedocs.io/en/latest/advanced.html#update-emmc-boot-partitions");
-		res = FALSE;
-		goto out;
-	}
-
 	g_message("Boot partition %s is now active", part_slot->device);
 
 	/* run slot post install hook if enabled */
